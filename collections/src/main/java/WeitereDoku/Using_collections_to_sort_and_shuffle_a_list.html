<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
    <meta http-equiv="content-type"
          content="text/html; charset=ISO-8859-1">
    <title>Using collections to sort and shuffle a list</title>
    <meta name="author" content="Andreas K&uuml;nkler">
</head>
<body>
<h3>USING COLLECTIONS TO SORT AND SHUFFLE A LIST</h3>
<p>The class <code>java.util.Collections</code> contains many methods
    designed to operate on objects that implement the <code>List</code>
    interface. This utility class includes methods to perform a binary
    search on a list for a specified object, to copy the elements of one
    list into another, and to swap elements at specified positions in a
    list. In this tip, you will investigate two simple methods in the <code>Collections</code>
    class: <code>shuffle()</code> and <code>rotate()</code>. Then you'll
    use another <code>Collections</code> method, <code>sort()</code>, to
    sort items in a list. To sort there must be some way to compare
    objects. In this tip, you will sort using <code>Comparable</code> and
    later a <code>Comparator</code>.</p>
<p>Let's start with the following example. You have a deck of six cards
    numbered zero through five. You display the initialized deck and then
    rotate it by two positions, that is, you call <code>rotate(2)</code>.
    This results in taking the bottom two cards, putting them on top of the
    deck, and moving everything else down. If you have a deck of n cards,
    then rotate for r&lt;n, amounts to "cutting the cards" so that you take
    n-r cards off the top of the deck and move those cards below the stack
    of cards that remains on the table.</p>
<p>If instead you call <code>rotate(-r)</code> then you are moving r
    cards from the top to the bottom. You can think of this as rotating r
    cards in the opposite direction or you can think of <code>rotate(n-r)</code>
    as being equivalent to <code>rotate(-r)</code>.</p>
<p>You can expect to get different results when you shuffle the cards.
    The <code>Collections</code> class javadocs describe the shuffling
    algorithm as producing results in all possible permutations with equal
    likelihood.</p>
<p>Here is a simple program that initializes and shuffles a deck of
    cards.</p>
<pre>   import java.util.List;<br>   import java.util.ArrayList;<br>   import java.util.Collections;<br><br>   public class CutAndShuffle {   <br><br>     private static List miniDeck = new ArrayList(6);<br><br>     private static void initializeDeck() {<br>       for (int i = 0; i &lt; 6; i++) {<br>         miniDeck.add(new Integer(i));<br>       }<br>     }<br><br>     private static void printDeck(String message) {<br>       System.out.println(message + "\n");<br>       for (int i = 0; i &lt; 6; i++) {<br>         System.out.println("card " + i +<br>                            " = " + miniDeck.get(i));<br>       }<br>       System.out.println("============");<br>     }<br><br>     public static void main(String[] args) {<br>       initializeDeck();<br>       printDeck("Initialized Deck:");<br>       Collections.rotate(miniDeck, 2);<br>       printDeck("Deck rotated by 2:");<br>       Collections.rotate(miniDeck, -2);<br>       printDeck("Deck rotated back by 2:");<br>       Collections.shuffle(miniDeck);<br>       printDeck("Deck Shuffled:");<br>     }<br>   }<br></pre>
<p>When you run the <code>CutAndShuffle</code> program, you should get
    output similar to the following. As previously noted, it is likely that
    your results from the call to <code>shuffle()</code> will be different.</p>
<pre> Initialized Deck:<br><br>   card 0 = 0<br>   card 1 = 1<br>   card 2 = 2<br>   card 3 = 3<br>   card 4 = 4<br>   card 5 = 5<br>   ============<br>   Deck rotated by 2:<br><br>   card 0 = 4<br>   card 1 = 5<br>   card 2 = 0<br>   card 3 = 1<br>   card 4 = 2<br>   card 5 = 3<br>   ============<br>   Deck rotated back by 2:<br><br>   card 0 = 0<br>   card 1 = 1<br>   card 2 = 2<br>   card 3 = 3<br>   card 4 = 4<br>   card 5 = 5<br>   ============<br>   Deck Shuffled:<br><br>   card 0 = 1<br>   card 1 = 2<br>   card 2 = 4<br>   card 3 = 5<br>   card 4 = 0<br>   card 5 = 3<br>   ============<br></pre>
<p>The <code>shuffle()</code> and <code>rotate()</code> methods in <code>Collections</code>
    do not depend on you being able to compare elements in any way. However
    sorting does require a way to compare elements. To apply a <code>sort()</code>
    you to need to determine which of two non-equivalent objects precedes
    the other. There are two ways to achieve this:</p>
<ul>
    <li>Ensure that the type of object that is sorted implements the <code>java.lang.Comparable</code>
        interface. This requires that the class has a method with the following
        signature:<br>
        <pre>     public int compareTo(Object  o)<br></pre>
    </li>
    <li>Create a companion class that implements <code>Comparator</code>
        and encapsulates the rules for comparing two objects of a certain type.
    </li>
</ul>
<p>In the first approach, if <code>o1</code> and <code>o2</code> are
    instances of a class that implements <code>Comparable</code>, then <code>o1.compareTo(o2)</code>
    should return <code>0</code> if the two objects are equal, a negative
    integer if <code>o1</code> is less than <code>o2</code>, and a
    positive integer if <code>o1</code> is greater than <code>o2</code>.
    The value of the returned integer is not important, the sign (positive
    or negative) is. So <code>o1.compareTo(o2)</code> must have the
    opposite sign of <code>o2.compareTo(o1)</code>. For three objects, <code>compareTo()</code>
    should reflect transitivity of the underlying comparison. In other
    words if <code>o1.compareTo(o2)&gt;0</code> and <code>o2.compareTo(o3)&gt;0</code>,
    then <code>o1.compareTo(o3)&gt;0</code>.</p>
<p>The second approach takes advantage of the fact that the wrapper
    classes, including <code>Integer</code>, implement <code>Comparable</code>.
    As a result, you can easily sort a <code>List</code> comprised of
    classes of type <code>Integer</code> using the <code>Collections.sort()</code>
    method. Here's an example:</p>
<pre>   import java.util.List;<br>   import java.util.ArrayList;<br>   import java.util.Collections;<br><br>   public class ShuffleAndSort {<br>     List miniDeck = new ArrayList(6);<br><br>     void initializeDeck() {<br>      for (int i = 0; i &lt; 6; i++) {<br>         createCard(i);<br>       }<br>     }<br><br>     void printDeck(String message) {<br>       System.out.println(message);<br>       for (int i = 0; i &lt; 6; i++) {<br>         System.out.println("card " + i +<br>           " = " + miniDeck.get(i));<br>       }<br>       System.out.println("============");<br>     }<br><br>     void createCard(int i) {<br>       miniDeck.add(new Integer(i));<br>     }<br><br>     void sort(){<br>       Collections.sort(miniDeck);<br>     }<br><br><br>     void exerciseDeck() {<br>       initializeDeck();<br>       Collections.shuffle(miniDeck);<br>       printDeck("Deck Shuffled:");<br>       sort();<br>       printDeck("Deck Sorted:");<br>     }<br><br><br>     public static void main(String[] args) {<br>       new ShuffleAndSort().exerciseDeck();<br>     }<br>   }<br></pre>
<p>The <code>ShuffleAndCode</code> program might appear to have excess
    methods. Certainly <code>createCard()</code> and <code>sort()</code>
    could be inlined. Creating separate methods makes it easy to extend the
    <code>ShuffleAndSort</code>
    class. You can do this by overriding these methods to vary what objects
    are added to the deck and how the deck is sorted. In this case you get
    a report that the deck is shuffled. You can then sort the deck using
    the method call:</p>
<pre>Collections.sort(miniDeck);</pre>
<p>The output from <code>ShuffleAndSort</code> should look something
    like the following.</p>
<pre>   Deck Shuffled:<br>   card 0 = 4<br>   card 1 = 2<br>   card 2 = 1<br>   card 3 = 3<br>   card 4 = 5<br>   card 5 = 0<br>   ============<br>   Deck Sorted:<br>   card 0 = 0<br>   card 1 = 1<br>   card 2 = 2<br>   card 3 = 3<br>   card 4 = 4<br>   card 5 = 5<br>   ============ <br></pre>
<p>The <code>miniDeck</code> is able to sort itself because <code>Integer</code>
    implements <code>Comparable</code>. You can also choose to sort it
    differently by using a different signature of the <code>sort()</code>
    method. This other signature takes the <code>List</code> to be sorted
    as the first argument and the <code>Comparator</code> object as the
    second object. You can replace the <code>sort()</code> method in <code>ShuffleAndSort</code>
    with the following:
</p>
<pre>   void sort(){<br>       Collections.sort(miniDeck,<br>                        Collections.reverseOrder());<br>   }  <br></pre>
<p>This time the deck will be sorted from high card to low card.</p>
<p>Suppose instead that you sort objects of a type that does not
    implement <code>Comparable</code>. Create, for example, the following <code>Rank</code>
    class:</p>
<pre>public class Rank {<br><br>     private int rank;<br><br>     public Rank(int rank) {<br>       this.rank = rank;<br>     }<br><br>     public int getRankInt(){<br>       return rank;<br>     }<br><br>     public String toString() {<br>       return "" + rank;<br>     }<br>   }<br></pre>
<p>Now create the following class that inherits from <code>ShuffleAndSort</code>
    and creates a deck of objects of type <code>Rank:</code></p>
<pre>   public class UseRank extends ShuffleAndSort {<br><br>     void createCard(int i) {<br>       miniDeck.add(new Rank(i));<br>     }<br><br>     public static void main(String[] args) {<br>       new UseRank().exerciseDeck();<br>     }<br>   }<br></pre>
<p>When you compile and run <code>UseRank</code> you get a <code>ClassCastException</code>.
    There are two ways to solve this problem:</p>
<ul>
    <li>You create a <code>Comparable</code> version of <code>Rank</code>.</li>
    <li>You store the rank as an <code>int</code> and implement <code>compareTo()</code>
        "by hand."
    </li>
</ul>
<p>The first solution takes advantage of the fact that <code>Integer</code>
    implements <code>Comparable</code> and stores the actual rank as an <code>Integer</code>
    and not an <code>int</code>. Then the <code>compareTo()</code> method
    calls the <code>compareTo()</code> method in the <code>Integer</code>
    class. Here's what this approach looks like:</p>
<pre>   public class ComparableRank implements Comparable {<br><br>     private Integer rank;<br><br>     public ComparableRank(int rank) {<br>       this.rank = new Integer(rank);<br>     }<br><br>     public String toString() {<br>       return "" + rank;<br>     }<br><br>     public int compareTo(Object o) {<br>       ComparableRank cr = (ComparableRank) o;<br>       return (rank.compareTo(cr.rank));<br>     }<br>   }<br></pre>
<p>In the second solution, you store the rank as an <code>int</code>,
    and you need to implement <code>compareTo()</code> like this:</p>
<pre>   public int compareTo(Object o) {<br>     ComparableRank2 cr = (ComparableRank2) o;<br>     return (rank - cr.rank);<br>   }<br></pre>
<p>Note that for the purposes of this tip, returning the difference of <code>rank</code>
    and <code>cr.rank</code> works fine. The <code>rank</code> attribute
    is non-negative and the deck size is smaller than 231-1. Here is a more
    careful implementation of <code>compareTo()</code>:</p>
<pre>  public int compareTo(Object o) {<br>     ComparableRank2 cr = (ComparableRank2) o;<br>     if (rank &lt; cr.rank) return -1;<br>     else return 1;<br>   }<br></pre>
<p>This assumes that the value of the rank attribute is unique in a
    deck. You could also extend this comparison to check for equality, in
    which case you would return 0.</p>
<p>In both approaches you should override <code>toString()</code> so
    that the printout matches the format from the previous examples. Here
    is an example of the second approach:</p>
<pre>   public class ComparableRank2 implements Comparable {<br><br>     private int rank;<br><br>     public ComparableRank2(int rank) {<br>       this.rank = rank;<br>     }<br><br>     public String toString() {<br>       return "" + rank;<br>     }<br><br>     public int compareTo(Object o) {<br>      ComparableRank2 cr = (ComparableRank2) o;<br>       return (rank - cr.rank);<br>     }<br>   }<br></pre>
<p>You can run these versions by changing the body of the <code>createCard()</code>
    method to load objects of type <code>ComparableRank</code> or of type <code>ComparableRank2</code>.</p>
<p>Recall the second way of determining which of two non-equivalent
    objects precedes the other in a sort: Create a companion class that
    implements <code>Comparator</code> and encapsulates the rules for
    comparing two objects of a certain type. Taking this approach with
    objects of type <code>Rank</code>, you fill the deck with objects of
    that type. Then you create a <code>Comparator</code> that is used to
    sort those objects. This solution is ideal to use with classes that you
    cannot alter or easily subclass. The <code>compare()</code> method in
    the following <code>RankComparator</code> class is essentially the
    same as the <code>compareTo()</code> method in <code>ComparableRank2</code>.
    You cast to the type of objects that you are supporting in this <code>Comparator</code>
    and then implement the comparison:</p>
<pre>   import java.util.Comparator;<br><br>   public class RankComparator implements Comparator {<br>     public int compare(Object o1, Object o2) {<br>       Rank r1 = (Rank) o1;<br>       Rank r2 = (Rank) o2;<br>       return r1.getRankInt() - r2.getRankInt();<br>     }<br>   }<br></pre>
<p>To use this new <code>RankComparator</code>, you simply override
    the <code>sort()</code> method from <code>UseRank</code> and pass in
    the <code>RankComparator</code> as the second argument:</p>
<pre>   import java.util.Collections;<br><br>   public class UseRankComparator extends UseRank {<br><br>     void sort() {<br>       Collections.sort(miniDeck, new RankComparator());<br>     }<br><br>     public static void main(String[] args) {<br>       new UseRankComparator().exerciseDeck();<br>     }<br>   }<br></pre>
<p>The output from <code>UseRankComparator</code> should look
    something like the following.</p>
<pre>   Deck Shuffled:<br>   card 0 = 0<br>   card 1 = 4<br>   card 2 = 5<br>   card 3 = 3<br>   card 4 = 1<br>   card 5 = 2<br>   ============<br>   Deck Sorted:<br>   card 0 = 0<br>   card 1 = 1<br>   card 2 = 2<br>   card 3 = 3<br>   card 4 = 4<br>   card 5 = 5<br>   ============   <br></pre>
<p>You have seen that when you want to sort a <code>List</code> it
    must be possible to compare the items in that list. You can use items
    of a type that implements <code>Comparable</code>.
    Fortunately, this includes the classes that wrap the primitive types. A
    second approach is to create a companion class that implements <code>Comparator</code>
    and encapsulates the rules for comparing two objects of a certain type.</p>
<p>For more information about <code>Collections</code>, see the <a
        href="http://enews.sun.com/CTServlet?id=637551642017623294:1089993958604">Collections
    trail</a> in the Java Tutorial.</p>
<!-- CSI:END_CONTENT -->
</body>
</html>
